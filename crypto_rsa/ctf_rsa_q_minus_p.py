'''
import gmpy2
from Crypto.Util.number import *
import uuid
print("flag is",flag)
m = bytes_to_long(flag)
p = getStrongPrime(1024)
q = getStrongPrime(1024)
print("q-p=",q-p)
n = p * q
e = 65537
c = pow(m, e, n)
print("c =",c)
print("n =",n)
print("e =",e)


output:
q-p= 20616457017715650893493638853343850129775352983273922300583412869399668480769033234552760254182825325903991527604627918968824704515469173353449562771796824869139711721013486243359368443576796960212774568677660193388206234523213212573295116494114839027484163113641452627443543761895445649816740257705827315242
c = 1662479561616533784401764980983949087581922284281681692273504404084642818313963068014192602990199974336083244698163784773276136947830338988240856592100829800552121004522662126538327923875124855203696241049779914750087413022737576710818941843140011124024601767915408476491671077991941953878258657025821165850181379721362928902389622384880768843153734618035228104178578639817485182021367113861649375945104135254538305808587065175182956303093091853615399301417005819970848812039628555816319740028908559076648169795951471871062066458940245715357301675884390545918473123262010663069785374119450692480043045515307154274480
n = 20881853918096804017699310311688191996664898357125160004179166070557341863196508209527177825983597017536230420142670001414008922370114140315647283110361738884422814797294963100624805048911964117825083631017790294165272774282877773165669303081648845538939862665614243398751688093380915417315359057017091946695196841612349423626594141680684569987573855192974015697242186949892787458571297506607950891441472219704820153051715381263819630217812747207474705174825621371850062590340082862992823077779445954168146724949923143890940658263129887401613613800342901591127600642370357079887407256313168239557875877600079722562763
e = 65537

思路
设 d=q−p，则我们可以建立以下方程：
n=p×q
q=p+d

将q代入n的表达式：
n=p×(p+d)=p^2+dp

整理成二次方程：
p^2+dp−n=0
解一元二次方程
'''

import math
from math import isqrt
from Crypto.Util.number import inverse, long_to_bytes


def rsa_decrypt(q_minus_p, n, e, c):
    # 1. 计算 p 和 q
    # 解方程 p^2 + (q-p)*p - n = 0
    # 判别式 Δ = (q-p)^2 + 4n
    delta = q_minus_p ** 2 + 4 * n
    sqrt_delta = isqrt(delta)
    if sqrt_delta * sqrt_delta != delta:
        raise ValueError("无法找到整数解，请检查输入是否正确")

    p = (-q_minus_p + sqrt_delta) // 2
    q = p + q_minus_p

    # 验证 p 和 q 是否正确
    if p * q != n:
        raise ValueError("计算出的 p 和 q 不正确，请检查输入")

    print(f"p = {p}")
    print(f"q = {q}")

    # 2. 计算欧拉函数 φ(n) = (p-1)(q-1)
    phi_n = (p - 1) * (q - 1)
    print(f"φ(n) = {phi_n}")

    # 3. 计算私钥 d = e^(-1) mod φ(n)
    d = inverse(e, phi_n)
    print(f"私钥 d = {d}")

    # 4. 解密密文 m = c^d mod n
    m = pow(c, d, n)
    print(f"解密后的明文 m = {m}")

    return m


# 模数 n = p * q
n = 20881853918096804017699310311688191996664898357125160004179166070557341863196508209527177825983597017536230420142670001414008922370114140315647283110361738884422814797294963100624805048911964117825083631017790294165272774282877773165669303081648845538939862665614243398751688093380915417315359057017091946695196841612349423626594141680684569987573855192974015697242186949892787458571297506607950891441472219704820153051715381263819630217812747207474705174825621371850062590340082862992823077779445954168146724949923143890940658263129887401613613800342901591127600642370357079887407256313168239557875877600079722562763

# q - p
q_minus_p = 20616457017715650893493638853343850129775352983273922300583412869399668480769033234552760254182825325903991527604627918968824704515469173353449562771796824869139711721013486243359368443576796960212774568677660193388206234523213212573295116494114839027484163113641452627443543761895445649816740257705827315242

# 公钥指数 e
e = 65537

# 密文 c
c = 1662479561616533784401764980983949087581922284281681692273504404084642818313963068014192602990199974336083244698163784773276136947830338988240856592100829800552121004522662126538327923875124855203696241049779914750087413022737576710818941843140011124024601767915408476491671077991941953878258657025821165850181379721362928902389622384880768843153734618035228104178578639817485182021367113861649375945104135254538305808587065175182956303093091853615399301417005819970848812039628555816319740028908559076648169795951471871062066458940245715357301675884390545918473123262010663069785374119450692480043045515307154274480

# 解密
try:
    m = rsa_decrypt(q_minus_p, n, e, c)
    mbytes = long_to_bytes(m)
    print('flag=' + mbytes.decode('utf-8'))
except ValueError as e:
    print(f"解密失败: {e}")