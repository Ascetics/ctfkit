import math
from Crypto.Util.number import long_to_bytes


def decrypt_with_dp(n, e, dp, c):
    # 尝试分解n
    m = 2  # 也可以多尝试几个不同的m
    p = math.gcd(pow(m, e * dp, n) - m, n)
    if p == 1 or p == n:
        # 如果失败，可以尝试其他m
        for m in [3, 5, 7, 11, 13]:
            p = math.gcd(pow(m, e * dp, n) - m, n)
            if p != 1 and p != n:
                break
    if p == 1 or p == n:
        raise ValueError("无法分解n")
    q = n // p
    print(f"p = {p}")
    print(f"q = {q}")

    # 计算phi_n
    phi_n = (p - 1) * (q - 1)

    # 计算私钥d
    d = pow(e, -1, phi_n)  # Python 3.8+ 可以使用内置的模逆
    # 如果Python版本较低，可以使用以下函数：
    # d = inverse(e, phi_n)

    # 解密密文
    plaintext = pow(c, d, n)
    return plaintext


# 如果pow不支持模逆，可以自己实现扩展欧几里得
def inverse(a, m):
    g, x, y = extended_gcd(a, m)
    if g != 1:
        raise ValueError("模逆不存在")
    return x % m


def extended_gcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = extended_gcd(b % a, a)
        return (g, x - (b // a) * y, y)


# 测试样例
# 已知n, e, dp, c
# 以下为示例值，实际使用时替换为已知值
n = 15436586506265382785524723267926444275462583019354383194654618933970433830434544481689625981207606375978708092558218246652496848076710411132268953499043735379180887935756772262155008862710764094267410967565241203605386593697737434875910984139143271151900377372693190411504735649123965519189648830868758032067
e = 65537
dp = 379731142995118368195086502083726192650138136864805821111741080341262318450359112900427553070639257250091100401461103206486523535760843615494638091936809
c = 854977693463411460490582164652536883002498905251706308634386005958509682016980677282553767296915296737583796051269333809745316569004849097563723358017329758234680761174609149316747091398434695986939450351231497326579265836956690907677434464255178122585307742001203732956675315052213672484434073446872723134

# 解密
try:
    m = decrypt_with_dp(n, e, dp, c)
    print(f"解密结果: {m}")
    txt_m = long_to_bytes(m).decode('utf-8')
    print(f'{txt_m}')
except ValueError as e:
    print(f"解密失败: {e}")